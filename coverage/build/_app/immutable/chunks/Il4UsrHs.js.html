<!doctype html>
<html lang="en">
	<head>
		<title>Code coverage report for build/_app/immutable/chunks/Il4UsrHs.js</title>
		<meta charset="utf-8" />
		<link rel="stylesheet" href="../../../../prettify.css" />
		<link rel="stylesheet" href="../../../../base.css" />
		<link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<style type="text/css">
			.coverage-summary .sorter {
				background-image: url(../../../../sort-arrow-sprite.png);
			}
		</style>
	</head>

	<body>
		<div class="wrapper">
			<div class="pad1">
				<h1>
					<a href="../../../../index.html">All files</a> /
					<a href="index.html">build/_app/immutable/chunks</a> Il4UsrHs.js
				</h1>
				<div class="clearfix">
					<div class="fl pad1y space-right2">
						<span class="strong">0% </span>
						<span class="quiet">Statements</span>
						<span class="fraction">0/4</span>
					</div>

					<div class="fl pad1y space-right2">
						<span class="strong">0% </span>
						<span class="quiet">Branches</span>
						<span class="fraction">0/1</span>
					</div>

					<div class="fl pad1y space-right2">
						<span class="strong">0% </span>
						<span class="quiet">Functions</span>
						<span class="fraction">0/1</span>
					</div>

					<div class="fl pad1y space-right2">
						<span class="strong">0% </span>
						<span class="quiet">Lines</span>
						<span class="fraction">0/4</span>
					</div>
				</div>
				<p class="quiet">
					Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>,
					<em>p</em> or <em>k</em> for the previous block.
				</p>
				<template id="filterTemplate">
					<div class="quiet">
						Filter:
						<input type="search" id="fileSearch" />
					</div>
				</template>
			</div>
			<div class="status-line low"></div>
			<pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >import{_ as X,aw as F,ax as Y,ay as _,az as H,l as i,c as V,aA as z,aB as U,ai as $,an as q,aj as P,ah as K,aC as Q,aD as W,aE as Z}from"./ChnUWdMC.js";import{G as B}from"./CUTqnTF-.js";import{l as I}from"./C2ZBUW1U.js";import{i as x}from"./Cm58ReCv.js";import{c as L}from"./Bj4VwP1D.js";import{m as A}from"./BO5zISR9.js";function p(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:ee(e),edges:ne(e)};return x(e.graph())||(t.value=L(e.graph())),t}function ee(e){return A(e.nodes(),function(t){var n=e.node(t),o=e.parent(t),c={v:t};return x(n)||(c.value=n),x(o)||(c.parent=o),c})}function ne(e){return A(e.edges(),function(t){var n=e.edge(t),o={v:t.v,w:t.w};return x(t.name)||(o.name=t.name),x(n)||(o.value=n),o})}var f=new Map,b=new Map,J=new Map,te=X(()=&gt;{b.clear(),J.clear(),f.clear()},"clear"),O=X((e,t)=&gt;{const n=b.get(t)||[];return i.trace("In isDescendant",t," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),se=X((e,t)=&gt;{const n=b.get(t)||[];return i.info("Descendants of ",t," is ",n),i.info("Edge is ",e),e.v===t||e.w===t?!1:n?n.includes(e.v)||O(e.v,t)||O(e.w,t)||n.includes(e.w):(i.debug("Tilt, ",t,",not in descendants"),!1)},"edgeInCluster"),G=X((e,t,n,o)=&gt;{i.warn("Copying children of ",e,"root",o,"data",t.node(e),o);const c=t.children(e)||[];e!==o&amp;&amp;c.push(e),i.warn("Copying (nodes) clusterId",e,"nodes",c),c.forEach(a=&gt;{if(t.children(a).length&gt;0)G(a,t,n,o);else{const r=t.node(a);i.info("cp ",a," to ",o," with parent ",e),n.setNode(a,r),o!==t.parent(a)&amp;&amp;(i.warn("Setting parent",a,t.parent(a)),n.setParent(a,t.parent(a))),e!==o&amp;&amp;a!==e?(i.debug("Setting parent",a,e),n.setParent(a,e)):(i.info("In copy ",e,"root",o,"data",t.node(e),o),i.debug("Not Setting parent for node=",a,"cluster!==rootId",e!==o,"node!==clusterId",a!==e));const u=t.edges(a);i.debug("Copying Edges",u),u.forEach(l=&gt;{i.info("Edge",l);const v=t.edge(l.v,l.w,l.name);i.info("Edge data",v,o);try{se(l,o)?(i.info("Copying as ",l.v,l.w,v,l.name),n.setEdge(l.v,l.w,v,l.name),i.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):i.info("Skipping copy of edge ",l.v,"--&gt;",l.w," rootId: ",o," clusterId:",e)}catch(C){i.error(C)}})}i.debug("Removing node",a),t.removeNode(a)})},"copy"),R=X((e,t)=&gt;{const n=t.children(e);let o=[...n];for(const c of n)J.set(c,e),o=[...o,...R(c,t)];return o},"extractDescendants"),ie=X((e,t,n)=&gt;{const o=e.edges().filter(l=&gt;l.v===t||l.w===t),c=e.edges().filter(l=&gt;l.v===n||l.w===n),a=o.map(l=&gt;({v:l.v===t?n:l.v,w:l.w===t?t:l.w})),r=c.map(l=&gt;({v:l.v,w:l.w}));return a.filter(l=&gt;r.some(v=&gt;l.v===v.v&amp;&amp;l.w===v.w))},"findCommonEdges"),D=X((e,t,n)=&gt;{const o=t.children(e);if(i.trace("Searching children of id ",e,o),o.length&lt;1)return e;let c;for(const a of o){const r=D(a,t,n),u=ie(t,n,r);if(r)if(u.length&gt;0)c=r;else return r}return c},"findNonClusterChild"),k=X(e=&gt;!f.has(e)||!f.get(e).externalConnections?e:f.has(e)?f.get(e).id:e,"getAnchorId"),re=X((e,t)=&gt;{if(!e||t&gt;10){i.debug("Opting out, no graph ");return}else i.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length&gt;0&amp;&amp;(i.warn("Cluster identified",n," Replacement id in edges: ",D(n,e,n)),b.set(n,R(n,e)),f.set(n,{id:D(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const o=e.children(n),c=e.edges();o.length&gt;0?(i.debug("Cluster identified",n,b),c.forEach(a=&gt;{const r=O(a.v,n),u=O(a.w,n);r^u&amp;&amp;(i.warn("Edge: ",a," leaves cluster ",n),i.warn("Descendants of XXX ",n,": ",b.get(n)),f.get(n).externalConnections=!0)})):i.debug("Not a cluster ",n,b)});for(let n of f.keys()){const o=f.get(n).id,c=e.parent(o);c!==n&amp;&amp;f.has(c)&amp;&amp;!f.get(c).externalConnections&amp;&amp;(f.get(n).id=c)}e.edges().forEach(function(n){const o=e.edge(n);i.warn("Edge "+n.v+" -&gt; "+n.w+": "+JSON.stringify(n)),i.warn("Edge "+n.v+" -&gt; "+n.w+": "+JSON.stringify(e.edge(n)));let c=n.v,a=n.w;if(i.warn("Fix XXX",f,"ids:",n.v,n.w,"Translating: ",f.get(n.v)," --- ",f.get(n.w)),f.get(n.v)||f.get(n.w)){if(i.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),c=k(n.v),a=k(n.w),e.removeEdge(n.v,n.w,n.name),c!==n.v){const r=e.parent(c);f.get(r).externalConnections=!0,o.fromCluster=n.v}if(a!==n.w){const r=e.parent(a);f.get(r).externalConnections=!0,o.toCluster=n.w}i.warn("Fix Replacing with XXX",c,a,n.name),e.setEdge(c,a,o,n.name)}}),i.warn("Adjusted Graph",p(e)),T(e,0),i.trace(f)},"adjustClustersAndEdges"),T=X((e,t)=&gt;{var c,a;if(i.warn("extractor - ",t,p(e),e.children("D")),t&gt;10){i.error("Bailing out");return}let n=e.nodes(),o=!1;for(const r of n){const u=e.children(r);o=o||u.length&gt;0}if(!o){i.debug("Done, no node has children",e.nodes());return}i.debug("Nodes = ",n,t);for(const r of n)if(i.debug("Extracting node",r,f,f.has(r)&amp;&amp;!f.get(r).externalConnections,!e.parent(r),e.node(r),e.children("D")," Depth ",t),!f.has(r))i.debug("Not a cluster",r,t);else if(!f.get(r).externalConnections&amp;&amp;e.children(r)&amp;&amp;e.children(r).length&gt;0){i.warn("Cluster without external connections, without a parent and with children",r,t);let l=e.graph().rankdir==="TB"?"LR":"TB";(a=(c=f.get(r))==null?void 0:c.clusterData)!=null&amp;&amp;a.dir&amp;&amp;(l=f.get(r).clusterData.dir,i.warn("Fixing dir",f.get(r).clusterData.dir,l));const v=new B({multigraph:!0,compound:!0}).setGraph({rankdir:l,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",p(e)),G(r,e,v,r),e.setNode(r,{clusterNode:!0,id:r,clusterData:f.get(r).clusterData,label:f.get(r).label,graph:v}),i.warn("New graph after copy node: (",r,")",p(v)),i.debug("Old graph after copy",p(e))}else i.warn("Cluster ** ",r," **not meeting the criteria !externalConnections:",!f.get(r).externalConnections," no parent: ",!e.parent(r)," children ",e.children(r)&amp;&amp;e.children(r).length&gt;0,e.children("D"),t),i.debug(f);n=e.nodes(),i.warn("New list of nodes",n);for(const r of n){const u=e.node(r);i.warn(" Now next level",r,u),u!=null&amp;&amp;u.clusterNode&amp;&amp;T(u.graph,t+1)}},"extractor"),M=X((e,t)=&gt;{if(t.length===0)return[];let n=Object.assign([],t);return t.forEach(o=&gt;{const c=e.children(o),a=M(e,c);n=[...n,...a]}),n},"sorter"),oe=X(e=&gt;M(e,e.children()),"sortNodesByHierarchy"),j=X(async(e,t,n,o,c,a)=&gt;{i.warn("Graph in recursive render:XAX",p(t),c);const r=t.graph().rankdir;i.trace("Dir in recursive render - dir:",r);const u=e.insert("g").attr("class","root");t.nodes()?i.info("Recursive render XXX",t.nodes()):i.info("No nodes found for",t),t.edges().length&gt;0&amp;&amp;i.info("Recursive edges",t.edge(t.edges()[0]));const l=u.insert("g").attr("class","clusters"),v=u.insert("g").attr("class","edgePaths"),C=u.insert("g").attr("class","edgeLabels"),g=u.insert("g").attr("class","nodes");await Promise.all(t.nodes().map(async function(d){const s=t.node(d);if(c!==void 0){const w=JSON.parse(JSON.stringify(c.clusterData));i.trace(`Setting data for parent cluster XXX<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" ></span></span></span>
<span class="cstat-no" title="statement not covered" > Node.id = `,d,`</span>
<span class="cstat-no" title="statement not covered" > data=`,w.height,`</span>
<span class="cstat-no" title="statement not covered" >Parent cluster`,c.height),t.setNode(c.id,w),t.parent(d)||(i.trace("Setting parent",d,c.id),t.setParent(d,c.id,w))}if(i.info("(Insert) Node XXX"+d+": "+JSON.stringify(t.node(d))),s!=null&amp;&amp;s.clusterNode){i.info("Cluster identified XBX",d,s.width,t.node(d));const{ranksep:w,nodesep:m}=t.graph();s.graph.setGraph({...s.graph.graph(),ranksep:w+25,nodesep:m});const N=await j(g,s.graph,n,o,t.node(d),a),S=N.elem;z(s,S),s.diff=N.diff||0,i.info("New compound node after recursive render XAX",d,"width",s.width,"height",s.height),U(S,s)}else t.children(d).length&gt;0?(i.trace("Cluster - the non recursive path XBX",d,s.id,s,s.width,"Graph:",t),i.trace(D(s.id,t)),f.set(s.id,{id:D(s.id,t),node:s})):(i.trace("Node - the non recursive path XAX",d,g,t.node(d),r),await $(g,t.node(d),{config:a,dir:r}))})),await X(async()=&gt;{const d=t.edges().map(async function(s){const w=t.edge(s.v,s.w,s.name);i.info("Edge "+s.v+" -&gt; "+s.w+": "+JSON.stringify(s)),i.info("Edge "+s.v+" -&gt; "+s.w+": ",s," ",JSON.stringify(t.edge(s))),i.info("Fix",f,"ids:",s.v,s.w,"Translating: ",f.get(s.v),f.get(s.w)),await Z(C,w)});await Promise.all(d)},"processEdges")(),i.info("Graph before layout:",JSON.stringify(p(t))),i.info("############################################# XXX"),i.info("###                Layout                 ### XXX"),i.info("############################################# XXX"),I(t),i.info("Graph after layout:",JSON.stringify(p(t)));let E=0,{subGraphTitleTotalMargin:y}=q(a);return await Promise.all(oe(t).map(async function(d){var w;const s=t.node(d);if(i.info("Position XBX =&gt; "+d+": ("+s.x,","+s.y,") width: ",s.width," height: ",s.height),s!=null&amp;&amp;s.clusterNode)s.y+=y,i.info("A tainted cluster node XBX1",d,s.id,s.width,s.height,s.x,s.y,t.parent(d)),f.get(s.id).node=s,P(s);else if(t.children(d).length&gt;0){i.info("A pure cluster node XBX1",d,s.id,s.x,s.y,s.width,s.height,t.parent(d)),s.height+=y,t.node(s.parentId);const m=(s==null?void 0:s.padding)/2||0,N=((w=s==null?void 0:s.labelBBox)==null?void 0:w.height)||0,S=N-m||0;i.debug("OffsetY",S,"labelHeight",N,"halfPadding",m),await K(l,s),f.get(s.id).node=s}else{const m=t.node(s.parentId);s.y+=y/2,i.info("A regular node XBX1 - using the padding",s.id,"parent",s.parentId,s.width,s.height,s.x,s.y,"offsetY",s.offsetY,"parent",m,m==null?void 0:m.offsetY,s),P(s)}})),t.edges().forEach(function(d){const s=t.edge(d);i.info("Edge "+d.v+" -&gt; "+d.w+": "+JSON.stringify(s),s),s.points.forEach(S=&gt;S.y+=y/2);const w=t.node(d.v);var m=t.node(d.w);const N=Q(v,s,f,n,w,m,o);W(s,N)}),t.nodes().forEach(function(d){const s=t.node(d);i.info(d,s.type,s.diff),s.isGroup&amp;&amp;(E=s.diff)}),i.warn("Returning from recursive render XAX",u,E),{elem:u,diff:E}},"recursiveRender"),ge=X(async(e,t)=&gt;{var a,r,u,l,v,C;const n=new B({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((a=e.config)==null?void 0:a.nodeSpacing)||((u=(r=e.config)==null?void 0:r.flowchart)==null?void 0:u.nodeSpacing)||e.nodeSpacing,ranksep:((l=e.config)==null?void 0:l.rankSpacing)||((C=(v=e.config)==null?void 0:v.flowchart)==null?void 0:C.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),o=t.select("g");F(o,e.markers,e.type,e.diagramId),Y(),_(),H(),te(),e.nodes.forEach(g=&gt;{n.setNode(g.id,{...g}),g.parentId&amp;&amp;n.setParent(g.id,g.parentId)}),i.debug("Edges:",e.edges),e.edges.forEach(g=&gt;{if(g.start===g.end){const h=g.start,E=h+"---"+h+"---1",y=h+"---"+h+"---2",d=n.node(h);n.setNode(E,{domId:E,id:E,parentId:d.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(E,d.parentId),n.setNode(y,{domId:y,id:y,parentId:d.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(y,d.parentId);const s=structuredClone(g),w=structuredClone(g),m=structuredClone(g);s.label="",s.arrowTypeEnd="none",s.id=h+"-cyclic-special-1",w.arrowTypeStart="none",w.arrowTypeEnd="none",w.id=h+"-cyclic-special-mid",m.label="",d.isGroup&amp;&amp;(s.fromCluster=h,m.toCluster=h),m.id=h+"-cyclic-special-2",m.arrowTypeStart="none",n.setEdge(h,E,s,h+"-cyclic-special-0"),n.setEdge(E,y,w,h+"-cyclic-special-1"),n.setEdge(y,h,m,h+"-cyc&lt;lic-special-2")}else n.setEdge(g.start,g.end,{...g},g.id)}),i.warn("Graph at first:",JSON.stringify(p(n))),re(n),i.warn("Graph after XAX:",JSON.stringify(p(n)));const c=V();await j(o,n,e.type,e.diagramId,void 0,c)},"render");export{ge as render};</span>
&nbsp;</pre></td></tr></table></pre>

			<div class="push"></div>
			<!-- for sticky footer -->
		</div>
		<!-- /wrapper -->
		<div class="footer quiet pad2 space-top1 center small">
			Code coverage generated by
			<a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
			at 2025-07-04T21:28:03.821Z
		</div>
		<script src="../../../../prettify.js"></script>
		<script>
			window.onload = function () {
				prettyPrint();
			};
		</script>
		<script src="../../../../sorter.js"></script>
		<script src="../../../../block-navigation.js"></script>
	</body>
</html>
