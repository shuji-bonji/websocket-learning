---
title: 'PWA統合アーキテクチャ詳細'
description: 'Progressive Web App統合、Service Worker連携、オフライン対応のWebSocketアーキテクチャ'
---

<script>
  import Mermaid from '$lib/components/Mermaid.svelte';
</script>

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

# 📱 PWA統合アーキテクチャ詳細

## 1. PWA + WebSocket統合システム

### Service Worker連携アーキテクチャ

</div>
</div>

<Mermaid chart={`
graph TB
    subgraph "PWAアプリケーション"
        UI[📱 PWA UI] --> SW[🔄 Service Worker]
        SW --> CACHE[💾 キャッシュストレージ]
        SW --> IDB[📂 IndexedDB]
        SW --> SYNC[🔄 Background Sync]
    end
    
    subgraph "ネットワーク層"
        UI -->|オンライン時| WS[WebSocketサーバー]
        SW -->|バックグラウンド| WS
        WS -->|プッシュ通知| PUSH[📲 Push Service]
        PUSH --> SW
    end
    
    subgraph "オフライン機能"
        SW --> QUEUE[📤 送信キュー]
        QUEUE --> RETRY[🔄 再送制御]
        CACHE --> OFFLINE[📱 オフラインUI]
        IDB --> HISTORY[📚 履歴管理]
    end
    
    subgraph "データ同期"
        SYNC --> CONFLICT[⚡ 競合解決]
        CONFLICT --> MERGE[🔄 マージ処理]
        MERGE --> WS
    end
    
    subgraph "通知システム"
        WS --> NOTIFY[🔔 Notification API]
        NOTIFY --> BADGE[🔴 バッジ更新]
        NOTIFY --> VIBRATE[📳 バイブレーション]
    end
    
    style SW fill:#f3e5f5
    style WS fill:#e8f5e8
    style SYNC fill:#fff3e0
    style NOTIFY fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

### オフライン・オンライン状態管理

</div>
</div>

<Mermaid chart={`
sequenceDiagram
    participant UI as PWA UI
    participant SW as Service Worker
    participant WS as WebSocketサーバー
    participant CACHE as キャッシュ
    participant QUEUE as 送信キュー

    Note over UI,QUEUE: オンライン状態
    UI->>WS: WebSocket接続
    WS->>UI: リアルタイムデータ
    UI->>CACHE: データキャッシュ
    
    Note over UI,QUEUE: オフライン移行
    UI->>SW: 接続失敗検知
    SW->>CACHE: キャッシュからデータ取得
    CACHE->>UI: オフラインデータ表示
    UI->>QUEUE: 送信データ蓄積
    
    Note over UI,QUEUE: オンライン復帰
    SW->>WS: 接続復旧
    QUEUE->>WS: 蓄積データ送信
    WS->>UI: 最新データ同期
    SW->>CACHE: キャッシュ更新
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 2. プッシュ通知統合システム

### マルチチャネル通知配信

</div>
</div>

<Mermaid chart={`
graph TD
    subgraph "通知トリガー"
        EVENT[📅 イベント発生] --> TRIGGER[⚡ 通知トリガー]
        SCHED[⏰ スケジュール] --> TRIGGER
        USER[👤 ユーザーアクション] --> TRIGGER
    end
    
    subgraph "通知判定"
        TRIGGER --> PREF[⚙️ 設定確認]
        PREF --> ONLINE[🌐 オンライン状態確認]
        ONLINE --> CHANNEL[📡 配信チャネル選択]
    end
    
    subgraph "PWA配信"
        CHANNEL -->|オンライン| WS[WebSocketサーバー]
        WS --> PWA[📱 PWAアプリ]
        PWA --> DISPLAY[📱 インアプリ通知]
    end
    
    subgraph "プッシュ配信"
        CHANNEL -->|オフライン| PUSH[📲 Push Service]
        PUSH --> SW[🔄 Service Worker]
        SW --> NOTIF[🔔 ブラウザ通知]
        SW --> BADGE[🔴 アプリバッジ]
    end
    
    subgraph "フォールバック"
        CHANNEL -->|失敗時| EMAIL[📧 メール通知]
        CHANNEL -->|失敗時| SMS[📱 SMS通知]
    end
    
    subgraph "分析・最適化"
        DISPLAY --> METRICS[📊 配信統計]
        NOTIF --> METRICS
        EMAIL --> METRICS
        METRICS --> OPT[⚡ 配信最適化]
    end
    
    style WS fill:#f3e5f5
    style PUSH fill:#e8f5e8
    style SW fill:#fff3e0
    style METRICS fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 3. オフラインファースト設計

### データ同期戦略

</div>
</div>

<Mermaid chart={`
graph LR
    subgraph "ローカルストレージ"
        UI[📱 ユーザーUI] --> LOCAL[💾 ローカルDB]
        LOCAL --> CACHE[⚡ キャッシュ層]
        CACHE --> INDEX[📂 IndexedDB]
    end
    
    subgraph "同期エンジン"
        CACHE --> SYNC[🔄 同期エンジン]
        SYNC --> DIFF[📊 差分計算]
        DIFF --> CONFLICT[⚡ 競合検知]
        CONFLICT --> RESOLVE[🔧 競合解決]
    end
    
    subgraph "サーバー連携"
        RESOLVE --> WS[WebSocketサーバー]
        WS --> SERVER[🗄️ サーバーDB]
        SERVER --> BACKUP[💾 バックアップ]
    end
    
    subgraph "同期パターン"
        WS --> REALTIME[⚡ リアルタイム同期]
        WS --> BATCH[📦 バッチ同期]
        WS --> EVENTUAL[🔄 結果整合性]
    end
    
    subgraph "同期制御"
        SYNC --> POLICY[📋 同期ポリシー]
        POLICY --> PRIORITY[📊 優先度制御]
        PRIORITY --> SCHEDULE[⏰ スケジューリング]
    end
    
    style SYNC fill:#f3e5f5
    style CONFLICT fill:#ffebee
    style WS fill:#e8f5e8
    style POLICY fill:#fff3e0
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

### 競合解決メカニズム

</div>
</div>

<Mermaid chart={`
sequenceDiagram
    participant A as クライアントA
    participant B as クライアントB
    participant S as 同期サーバー
    participant R as 競合解決エンジン

    Note over A,R: 同期競合シナリオ
    
    A->>S: データ更新 (v1 -> v2)
    B->>S: データ更新 (v1 -> v3)
    
    S->>R: 競合検知 (v2 vs v3)
    R->>R: 競合解決アルゴリズム実行
    
    alt Last Writer Wins
        R->>S: v3を採用 (最新タイムスタンプ)
        S->>A: v3に更新指示
        S->>B: v3確認
    else Merge Resolution
        R->>S: v2とv3をマージしてv4生成
        S->>A: v4に更新指示
        S->>B: v4に更新指示
    else User Resolution
        R->>A: 競合解決UI表示
        A->>R: ユーザー選択
        R->>S: 選択結果適用
        S->>B: 解決結果配信
    end
    
    Note over A,R: 一貫性復旧完了
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 4. PWAライフサイクル管理

### アプリケーション状態管理

</div>
</div>

<Mermaid chart={`
graph TD
    subgraph "PWAライフサイクル"
        INSTALL[📥 アプリインストール] --> ACTIVE[✅ アクティブ状態]
        ACTIVE --> BACKGROUND[🔄 バックグラウンド]
        BACKGROUND --> FOREGROUND[📱 フォアグラウンド]
        FOREGROUND --> ACTIVE
        ACTIVE --> SUSPEND[😴 サスペンド]
        SUSPEND --> ACTIVE
    end
    
    subgraph "WebSocket管理"
        ACTIVE --> CONNECT[🔌 WebSocket接続]
        BACKGROUND --> MAINTAIN[🔄 接続維持]
        SUSPEND --> DISCONNECT[❌ 接続切断]
        FOREGROUND --> RECONNECT[🔄 再接続]
    end
    
    subgraph "データ管理"
        CONNECT --> REALTIME[⚡ リアルタイム受信]
        MAINTAIN --> HEARTBEAT[💓 ハートビート]
        DISCONNECT --> QUEUE[📤 送信キュー]
        RECONNECT --> SYNC[🔄 データ同期]
    end
    
    subgraph "リソース最適化"
        BACKGROUND --> THROTTLE[⏳ 処理間引き]
        SUSPEND --> CLEANUP[🧹 リソース解放]
        FOREGROUND --> RESUME[▶️ 処理再開]
    end
    
    style CONNECT fill:#e8f5e8
    style MAINTAIN fill:#fff3e0
    style SYNC fill:#f3e5f5
    style THROTTLE fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 5. パフォーマンス最適化

### キャッシュ戦略とデータ圧縮

</div>
</div>

<Mermaid chart={`
graph TB
    subgraph "キャッシュ階層"
        L1[⚡ L1: メモリキャッシュ] --> L2[💾 L2: ブラウザキャッシュ]
        L2 --> L3[📂 L3: IndexedDB]
        L3 --> L4[🌐 L4: CDNキャッシュ]
    end
    
    subgraph "データ圧縮"
        WS[WebSocketサーバー] --> COMP[🗜️ 圧縮エンジン]
        COMP --> GZIP[📦 Gzip圧縮]
        COMP --> DELTA[🔄 差分圧縮]
        COMP --> BINARY[💾 バイナリ形式]
    end
    
    subgraph "配信最適化"
        COMP --> ADAPTIVE[📊 適応配信]
        ADAPTIVE --> BANDWIDTH[📡 帯域幅検知]
        BANDWIDTH --> QUALITY[🎛️ 品質調整]
        QUALITY --> PRIORITY[📊 優先度制御]
    end
    
    subgraph "プリロード戦略"
        L1 --> PREFETCH[🔮 プリフェッチ]
        PREFETCH --> PREDICT[🤖 予測読み込み]
        PREDICT --> CRITICAL[🎯 クリティカルパス]
    end
    
    style COMP fill:#f3e5f5
    style ADAPTIVE fill:#e8f5e8
    style PREFETCH fill:#fff3e0
    style CRITICAL fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 6. セキュリティ実装

### PWAセキュリティアーキテクチャ

</div>
</div>

<Mermaid chart={`
graph LR
    subgraph "認証・認可"
        USER[👤 ユーザー] --> AUTH[🔐 認証システム]
        AUTH --> JWT[🎫 JWTトークン]
        JWT --> REFRESH[🔄 リフレッシュ]
    end
    
    subgraph "通信セキュリティ"
        JWT --> WSS[🔒 WSS (WebSocket Secure)]
        WSS --> TLS[🛡️ TLS 1.3]
        TLS --> CERT[📜 証明書検証]
    end
    
    subgraph "データ保護"
        WSS --> ENCRYPT[🔐 メッセージ暗号化]
        ENCRYPT --> SIGN[✍️ デジタル署名]
        SIGN --> INTEGRITY[🔍 完全性検証]
    end
    
    subgraph "ローカルセキュリティ"
        ENCRYPT --> STORAGE[💾 セキュアストレージ]
        STORAGE --> KEYCHAIN[🔑 キーチェーン]
        KEYCHAIN --> SANDBOX[📦 サンドボックス]
    end
    
    subgraph "監査・監視"
        INTEGRITY --> LOG[📋 セキュリティログ]
        LOG --> SIEM[🚨 SIEM連携]
        SIEM --> ALERT[🔔 セキュリティアラート]
    end
    
    style AUTH fill:#f3e5f5
    style WSS fill:#e8f5e8
    style ENCRYPT fill:#fff3e0
    style LOG fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 💡 実装のベストプラクティス

### 1. Service Worker WebSocket管理
```javascript
// service-worker.js
class PWAWebSocketManager {
  constructor() {
    this.ws = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.messageQueue = [];
  }
  
  connect() {
    if (this.ws?.readyState === WebSocket.OPEN) return;
    
    this.ws = new WebSocket('wss://api.example.com/ws');
    
    this.ws.onopen = () => {
      console.log('WebSocket connected in SW');
      this.reconnectAttempts = 0;
      this.flushMessageQueue();
    };
    
    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.handleMessage(data);
    };
    
    this.ws.onclose = () => {
      this.scheduleReconnect();
    };
  }
  
  handleMessage(data) {
    // バックグラウンドでのメッセージ処理
    if (data.type === 'notification') {
      this.showNotification(data);
    } else if (data.type === 'update') {
      this.updateCache(data);
    }
  }
  
  showNotification(data) {
    self.registration.showNotification(data.title, {
      body: data.body,
      icon: '/icon-192x192.png',
      badge: '/badge-72x72.png',
      actions: data.actions || [],
      tag: data.tag,
      requireInteraction: data.urgent
    });
  }
}
```

### 2. オフライン対応データ同期
```javascript
class OfflineDataSync {
  constructor() {
    this.db = new IDBDatabase('pwa-data');
    this.syncQueue = new Map();
    this.conflictResolver = new ConflictResolver();
  }
  
  async saveData(key, data) {
    // ローカル保存
    await this.db.put('data', { key, data, timestamp: Date.now() });
    
    // オンライン時は即座同期
    if (navigator.onLine) {
      this.syncToServer(key, data);
    } else {
      // オフライン時はキューに追加
      this.syncQueue.set(key, { data, timestamp: Date.now() });
    }
  }
  
  async syncToServer(key, data) {
    try {
      const response = await fetch('/api/sync', {
        method: 'POST',
        body: JSON.stringify({ key, data }),
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (!response.ok) {
        throw new Error('Sync failed');
      }
      
      // 成功時はキューから削除
      this.syncQueue.delete(key);
    } catch (error) {
      // 失敗時はキューに追加
      this.syncQueue.set(key, { data, timestamp: Date.now() });
    }
  }
  
  async resolveConflicts() {
    for (const [key, localData] of this.syncQueue) {
      const serverData = await this.fetchServerData(key);
      
      if (serverData && serverData.timestamp > localData.timestamp) {
        // サーバー側が新しい場合
        const resolved = await this.conflictResolver.resolve(
          localData.data, 
          serverData.data
        );
        await this.saveData(key, resolved);
      }
    }
  }
}
```

### 3. プッシュ通知統合
```javascript
class PWAPushNotifications {
  constructor() {
    this.registration = null;
    this.subscription = null;
  }
  
  async initialize() {
    // Service Worker登録
    this.registration = await navigator.serviceWorker.register('/sw.js');
    
    // プッシュ通知権限要求
    const permission = await Notification.requestPermission();
    if (permission === 'granted') {
      await this.subscribeToPush();
    }
  }
  
  async subscribeToPush() {
    const vapidPublicKey = 'BEl62iUYgUivxIkv69yViEuiBIa40HI80Y...';
    
    this.subscription = await this.registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: this.urlBase64ToUint8Array(vapidPublicKey)
    });
    
    // サーバーに登録情報送信
    await this.sendSubscriptionToServer(this.subscription);
  }
  
  async sendSubscriptionToServer(subscription) {
    const ws = new WebSocket('wss://api.example.com/ws');
    
    ws.onopen = () => {
      ws.send(JSON.stringify({
        type: 'subscribe',
        subscription: subscription.toJSON()
      }));
    };
  }
  
  urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
      .replace(/-/g, '+')
      .replace(/_/g, '/');
    
    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    
    for (let i = 0; i < rawData.length; ++i) {
      outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
  }
}
```

### 4. 適応的品質制御
```javascript
class AdaptiveQualityController {
  constructor() {
    this.connection = navigator.connection || navigator.mozConnection;
    this.qualitySettings = {
      '4g': { compression: 'medium', updateRate: 100 },
      '3g': { compression: 'high', updateRate: 500 },
      '2g': { compression: 'max', updateRate: 2000 }
    };
  }
  
  getOptimalSettings() {
    const effectiveType = this.connection?.effectiveType || '4g';
    const downlink = this.connection?.downlink || 10;
    
    let settings = this.qualitySettings[effectiveType];
    
    // 動的調整
    if (downlink < 1) {
      settings = { ...settings, compression: 'max', updateRate: 5000 };
    } else if (downlink > 10) {
      settings = { ...settings, compression: 'none', updateRate: 50 };
    }
    
    return settings;
  }
  
  adaptWebSocketSettings(ws) {
    const settings = this.getOptimalSettings();
    
    // WebSocketサーバーに品質設定を通知
    ws.send(JSON.stringify({
      type: 'quality_settings',
      compression: settings.compression,
      updateRate: settings.updateRate
    }));
    
    // 接続状態監視
    this.connection?.addEventListener('change', () => {
      const newSettings = this.getOptimalSettings();
      ws.send(JSON.stringify({
        type: 'quality_settings',
        compression: newSettings.compression,
        updateRate: newSettings.updateRate
      }));
    });
  }
}
```

この包括的なPWA統合アーキテクチャにより、オフライン対応かつ高性能なWebSocketアプリケーションを構築できます。

</div>
</div>