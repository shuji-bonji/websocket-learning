---
title: 'バックエンド統合システム詳細'
description: 'マイクロサービス、API Gateway、分散アーキテクチャのWebSocket統合パターン'
---

<script>
  import Mermaid from '$lib/components/Mermaid.svelte';
</script>

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

# 🔧 バックエンド統合システム詳細

## 1. マイクロサービスアーキテクチャ

### WebSocket Gateway統合パターン

</div>
</div>

<Mermaid chart={`
graph TB
    subgraph "フロントエンド"
        WEB[💻 Webクライアント] --> GATE[🌐 API Gateway]
        MOBILE[📱 モバイルアプリ] --> GATE
        DESKTOP[🖥️ デスクトップアプリ] --> GATE
    end
    
    subgraph "WebSocket層"
        GATE --> WS[WebSocketサーバー]
        WS --> BROKER[📡 メッセージブローカー]
        BROKER --> ROUTER[🔄 ルーティングエンジン]
    end
    
    subgraph "マイクロサービス群"
        ROUTER --> USER[👤 ユーザーサービス]
        ROUTER --> ORDER[📦 注文サービス]
        ROUTER --> PAYMENT[💳 決済サービス]
        ROUTER --> INVENTORY[📊 在庫サービス]
        ROUTER --> NOTIFY[🔔 通知サービス]
    end
    
    subgraph "データ層"
        USER --> USERDB[💾 ユーザーDB]
        ORDER --> ORDERDB[💾 注文DB]
        PAYMENT --> PAYMENTDB[💾 決済DB]
        INVENTORY --> INVENTORYDB[💾 在庫DB]
    end
    
    subgraph "外部連携"
        PAYMENT --> STRIPE[💳 Stripe API]
        NOTIFY --> PUSH[📲 プッシュサービス]
        INVENTORY --> ERP[💼 ERPシステム]
    end
    
    style GATE fill:#f3e5f5
    style WS fill:#e8f5e8
    style BROKER fill:#fff3e0
    style ROUTER fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

### イベント駆動アーキテクチャ

</div>
</div>

<Mermaid chart={`
sequenceDiagram
    participant C as クライアント
    participant G as API Gateway
    participant WS as WebSocketサーバー
    participant B as メッセージブローカー
    participant O as 注文サービス
    participant I as 在庫サービス
    participant N as 通知サービス

    C->>G: 注文作成要求
    G->>O: 注文処理
    O->>B: OrderCreated イベント発行
    
    par 並列処理
        B->>I: 在庫確認・減少
        B->>N: 注文確認通知準備
    end
    
    I->>B: InventoryUpdated イベント
    N->>B: NotificationReady イベント
    
    B->>WS: リアルタイム更新配信
    WS->>C: 注文状況リアルタイム通知
    
    alt 在庫不足の場合
        I->>B: OutOfStock イベント
        B->>O: 注文キャンセル処理
        O->>B: OrderCancelled イベント
        B->>WS: キャンセル通知配信
    end
    
    Note over C,N: イベント駆動による疎結合設計
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 2. API Gateway統合パターン

### WebSocket・REST・GraphQL統合

</div>
</div>

<Mermaid chart={`
graph TD
    subgraph "クライアント層"
        SPA[📱 SPAアプリ] --> GATE[🌐 API Gateway]
        MOBILE[📱 Native App] --> GATE
        IOT[🌐 IoTデバイス] --> GATE
    end
    
    subgraph "プロトコル変換"
        GATE --> REST[🔗 REST API]
        GATE --> WS[WebSocket]
        GATE --> GQL[📊 GraphQL]
        GATE --> GRPC[⚡ gRPC]
    end
    
    subgraph "認証・認可"
        REST --> AUTH[🔐 認証サービス]
        WS --> AUTH
        GQL --> AUTH
        AUTH --> JWT[🎫 JWT検証]
        JWT --> RBAC[🛡️ RBAC制御]
    end
    
    subgraph "ロードバランシング"
        REST --> LB1[⚖️ REST LB]
        WS --> LB2[⚖️ WebSocket LB]
        GQL --> LB3[⚖️ GraphQL LB]
    end
    
    subgraph "バックエンドサービス"
        LB1 --> SERVICE1[🔧 サービス群A]
        LB2 --> SERVICE2[🔧 サービス群B]
        LB3 --> SERVICE3[🔧 サービス群C]
    end
    
    subgraph "監視・ログ"
        GATE --> METRICS[📊 メトリクス収集]
        GATE --> LOGS[📋 ログ集約]
        GATE --> TRACE[🔍 分散トレーシング]
    end
    
    style GATE fill:#f3e5f5
    style AUTH fill:#e8f5e8
    style LB2 fill:#fff3e0
    style METRICS fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

### レート制限・スロットリング

</div>
</div>

<Mermaid chart={`
graph LR
    subgraph "リクエスト流入"
        CLIENT[👤 クライアント] --> RATE[📊 レート制限]
        RATE --> BUCKET[🪣 Token Bucket]
        BUCKET --> WINDOW[⏰ Sliding Window]
    end
    
    subgraph "制限アルゴリズム"
        WINDOW --> FIXED[📏 Fixed Window]
        WINDOW --> SLIDING[🔄 Sliding Log]
        WINDOW --> ADAPTIVE[🎯 適応制御]
    end
    
    subgraph "制限判定"
        ADAPTIVE --> ALLOW[✅ 許可]
        ADAPTIVE --> THROTTLE[⏳ スロットリング]
        ADAPTIVE --> REJECT[❌ 拒否]
    end
    
    subgraph "WebSocket適用"
        ALLOW --> WS[WebSocketサーバー]
        THROTTLE --> DELAY[⏱️ 遅延配信]
        REJECT --> ERROR[🚫 エラー通知]
    end
    
    subgraph "動的調整"
        WS --> MONITOR[📊 監視]
        MONITOR --> FEEDBACK[🔄 フィードバック]
        FEEDBACK --> ADAPTIVE
    end
    
    style RATE fill:#f3e5f5
    style ADAPTIVE fill:#e8f5e8
    style WS fill:#fff3e0
    style MONITOR fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 3. データベース統合パターン

### CQRS + Event Sourcing

</div>
</div>

<Mermaid chart={`
graph TB
    subgraph "コマンド側 (書き込み)"
        CMD[📝 コマンド] --> VALIDATE[✅ 検証]
        VALIDATE --> AGGREGATE[📦 集約]
        AGGREGATE --> EVENT[📅 イベント生成]
        EVENT --> STORE[💾 イベントストア]
    end
    
    subgraph "イベントストリーム"
        STORE --> STREAM[🌊 イベントストリーム]
        STREAM --> HANDLER[🔄 イベントハンドラー]
        HANDLER --> PROJECTION[📊 プロジェクション更新]
    end
    
    subgraph "クエリ側 (読み込み)"
        PROJECTION --> READ_DB[📖 読み取り専用DB]
        READ_DB --> QUERY[🔍 クエリ]
        QUERY --> VIEW[👁️ ビューモデル]
    end
    
    subgraph "WebSocket統合"
        HANDLER --> WS[WebSocketサーバー]
        WS --> PUSH[📡 リアルタイム配信]
        PUSH --> CLIENT[👤 クライアント]
    end
    
    subgraph "プロジェクション種類"
        PROJECTION --> USER_VIEW[👤 ユーザービュー]
        PROJECTION --> ORDER_VIEW[📦 注文ビュー]
        PROJECTION --> ANALYTICS[📈 分析ビュー]
    end
    
    style AGGREGATE fill:#f3e5f5
    style STREAM fill:#e8f5e8
    style WS fill:#fff3e0
    style READ_DB fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

### 分散データ同期

</div>
</div>

<Mermaid chart={`
sequenceDiagram
    participant A as ノードA
    participant C as Coordinator
    participant B as ノードB
    participant D as ノードC
    participant W as WebSocketクライアント

    Note over A,W: 分散書き込み処理
    
    A->>C: 書き込み要求
    C->>C: トランザクションID生成
    
    par 2フェーズコミット準備
        C->>A: PREPARE
        C->>B: PREPARE  
        C->>D: PREPARE
    end
    
    par 応答待ち
        A->>C: PREPARED
        B->>C: PREPARED
        D->>C: PREPARED
    end
    
    C->>C: 全ノード準備完了確認
    
    par コミット実行
        C->>A: COMMIT
        C->>B: COMMIT
        C->>D: COMMIT
    end
    
    par コミット完了
        A->>C: COMMITTED
        B->>C: COMMITTED
        D->>C: COMMITTED
    end
    
    C->>W: 変更通知配信
    W->>W: データ更新反映
    
    Note over A,W: 分散一貫性保証
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 4. サーバーレス統合

### FaaS + WebSocketアーキテクチャ

</div>
</div>

<Mermaid chart={`
graph TD
    subgraph "クライアント層"
        CLIENT[📱 クライアント] --> APIGW[🌐 API Gateway]
    end
    
    subgraph "WebSocket管理"
        APIGW --> WSAPI[🔌 WebSocket API]
        WSAPI --> CONNECT[🔗 接続管理]
        CONNECT --> DYNAMODB[💾 接続DB]
    end
    
    subgraph "イベント処理"
        WSAPI --> SQS[📤 SQSキュー]
        SQS --> LAMBDA[⚡ Lambda関数]
        LAMBDA --> BUSINESS[🔧 ビジネスロジック]
    end
    
    subgraph "データ処理"
        BUSINESS --> RDS[🗄️ RDSデータベース]
        BUSINESS --> S3[📦 S3ストレージ]
        BUSINESS --> REDIS[⚡ ElastiCache]
    end
    
    subgraph "メッセージ配信"
        BUSINESS --> SNS[📢 SNS通知]
        SNS --> FANOUT[📡 ファンアウト]
        FANOUT --> LAMBDA2[⚡ 配信Lambda]
        LAMBDA2 --> WSAPI
    end
    
    subgraph "監視・ログ"
        LAMBDA --> CLOUDWATCH[📊 CloudWatch]
        LAMBDA2 --> CLOUDWATCH
        CLOUDWATCH --> ALARM[🚨 アラーム]
    end
    
    style WSAPI fill:#f3e5f5
    style LAMBDA fill:#e8f5e8
    style SNS fill:#fff3e0
    style CLOUDWATCH fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 5. メッセージキュー統合

### 高信頼性メッセージング

</div>
</div>

<Mermaid chart={`
graph LR
    subgraph "プロデューサー"
        SERVICE[🔧 マイクロサービス] --> KAFKA[📡 Kafka Producer]
        KAFKA --> PARTITION[📊 パーティション]
    end
    
    subgraph "メッセージブローカー"
        PARTITION --> CLUSTER[🌐 Kafkaクラスター]
        CLUSTER --> REPLICA[📋 レプリケーション]
        REPLICA --> PERSISTENCE[💾 永続化]
    end
    
    subgraph "コンシューマー"
        CLUSTER --> WS_CONSUMER[🔌 WebSocketコンシューマー]
        CLUSTER --> EMAIL_CONSUMER[📧 メールコンシューマー]
        CLUSTER --> ANALYTICS_CONSUMER[📊 分析コンシューマー]
    end
    
    subgraph "WebSocket配信"
        WS_CONSUMER --> FILTER[🔍 フィルタリング]
        FILTER --> TRANSFORM[🔄 データ変換]
        TRANSFORM --> WS[WebSocketサーバー]
        WS --> CLIENT[👤 クライアント]
    end
    
    subgraph "信頼性保証"
        WS_CONSUMER --> ACK[✅ 配信確認]
        ACK --> RETRY[🔄 再送制御]
        RETRY --> DLQ[💀 Dead Letter Queue]
    end
    
    style CLUSTER fill:#f3e5f5
    style WS_CONSUMER fill:#e8f5e8
    style FILTER fill:#fff3e0
    style ACK fill:#e3f2fd
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

### メッセージ順序保証

</div>
</div>

<Mermaid chart={`
sequenceDiagram
    participant P as プロデューサー
    participant K as Kafkaブローカー
    participant WS as WebSocketサーバー
    participant C1 as クライアント1
    participant C2 as クライアント2

    Note over P,C2: メッセージ順序保証シナリオ
    
    P->>K: Message 1 (Key: user123, Offset: 100)
    P->>K: Message 2 (Key: user123, Offset: 101)
    P->>K: Message 3 (Key: user123, Offset: 102)
    
    Note over K: 同一キーのメッセージは同一パーティション
    
    K->>WS: 順次コンシューム (Offset順)
    WS->>WS: クライアント別配信キュー作成
    
    WS->>C1: Message 1 配信
    C1->>WS: ACK受信
    WS->>C1: Message 2 配信
    C1->>WS: ACK受信
    WS->>C1: Message 3 配信
    
    alt 配信失敗時
        WS->>C2: Message 1 配信
        Note over C2: ネットワーク障害
        WS->>WS: 再送待ちキューに保持
        WS->>C2: Message 1 再送
        C2->>WS: ACK受信
        WS->>C2: Message 2 配信 (順序保証)
    end
    
    Note over P,C2: ユーザー別順序保証完了
`} />

<div class="bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
<div class="prose max-w-none p-8">

## 💡 実装のベストプラクティス

### 1. API Gateway WebSocket統合
```javascript
class WebSocketGateway {
  constructor() {
    this.connections = new Map();
    this.routes = new Map();
    this.middlewares = [];
    this.rateLimiter = new RateLimiter();
  }
  
  async handleConnection(ws, request) {
    // 認証・認可
    const token = this.extractToken(request);
    const user = await this.authenticateToken(token);
    
    if (!user) {
      ws.close(1008, 'Unauthorized');
      return;
    }
    
    // 接続管理
    const connectionId = this.generateConnectionId();
    this.connections.set(connectionId, {
      ws,
      user,
      subscriptions: new Set(),
      lastActivity: Date.now()
    });
    
    // メッセージルーティング
    ws.on('message', async (data) => {
      await this.routeMessage(connectionId, data);
    });
    
    ws.on('close', () => {
      this.connections.delete(connectionId);
    });
  }
  
  async routeMessage(connectionId, data) {
    const connection = this.connections.get(connectionId);
    if (!connection) return;
    
    try {
      const message = JSON.parse(data);
      
      // レート制限チェック
      if (!this.rateLimiter.checkLimit(connection.user.id)) {
        connection.ws.send(JSON.stringify({
          error: 'Rate limit exceeded'
        }));
        return;
      }
      
      // ルーティング
      const handler = this.routes.get(message.type);
      if (handler) {
        await handler(connection, message);
      }
      
    } catch (error) {
      console.error('Message routing error:', error);
      connection.ws.send(JSON.stringify({
        error: 'Invalid message format'
      }));
    }
  }
  
  registerRoute(messageType, handler) {
    this.routes.set(messageType, handler);
  }
  
  broadcastToSubscribers(topic, message) {
    for (const [id, connection] of this.connections) {
      if (connection.subscriptions.has(topic)) {
        connection.ws.send(JSON.stringify(message));
      }
    }
  }
}
```

### 2. イベント駆動マイクロサービス
```javascript
class EventDrivenService {
  constructor(serviceName) {
    this.serviceName = serviceName;
    this.eventBus = new EventBus();
    this.handlers = new Map();
    this.saga = new SagaOrchestrator();
  }
  
  async publishEvent(eventType, payload) {
    const event = {
      id: uuidv4(),
      type: eventType,
      source: this.serviceName,
      timestamp: new Date().toISOString(),
      payload
    };
    
    // イベントストア保存
    await this.eventStore.append(event);
    
    // メッセージブローカーに発行
    await this.eventBus.publish(eventType, event);
    
    // WebSocket配信
    this.websocketGateway.broadcastEvent(event);
  }
  
  subscribeToEvent(eventType, handler) {
    this.handlers.set(eventType, handler);
    this.eventBus.subscribe(eventType, async (event) => {
      try {
        await handler(event);
        // 処理成功をログ
        this.logEventProcessing(event, 'success');
      } catch (error) {
        // エラーハンドリング
        this.logEventProcessing(event, 'error', error);
        await this.handleEventError(event, error);
      }
    });
  }
  
  async handleEventError(event, error) {
    // 再試行ロジック
    if (event.retryCount < 3) {
      event.retryCount = (event.retryCount || 0) + 1;
      setTimeout(() => {
        this.eventBus.publish(event.type, event);
      }, Math.pow(2, event.retryCount) * 1000);
    } else {
      // Dead Letter Queue に送信
      await this.deadLetterQueue.send(event, error);
    }
  }
  
  startSaga(sagaType, initialEvent) {
    return this.saga.start(sagaType, initialEvent);
  }
}
```

### 3. CQRS実装パターン
```javascript
class CQRSSystem {
  constructor() {
    this.commandBus = new CommandBus();
    this.queryBus = new QueryBus();
    this.eventStore = new EventStore();
    this.projections = new Map();
  }
  
  // コマンド処理
  async executeCommand(command) {
    const handler = this.commandBus.getHandler(command.type);
    
    // 集約の現在状態を取得
    const aggregate = await this.loadAggregate(command.aggregateId);
    
    // ドメインロジック実行
    const events = await handler.handle(aggregate, command);
    
    // イベント保存
    await this.eventStore.saveEvents(command.aggregateId, events);
    
    // プロジェクション更新
    await this.updateProjections(events);
    
    // WebSocket配信
    await this.broadcastEvents(events);
    
    return events;
  }
  
  // クエリ処理
  async executeQuery(query) {
    const handler = this.queryBus.getHandler(query.type);
    const projection = this.projections.get(query.projectionType);
    
    return await handler.handle(projection, query);
  }
  
  async updateProjections(events) {
    for (const event of events) {
      const projectionHandlers = this.getProjectionHandlers(event.type);
      
      await Promise.all(
        projectionHandlers.map(handler => handler.handle(event))
      );
    }
  }
  
  async broadcastEvents(events) {
    for (const event of events) {
      // 関係するクライアントにのみ配信
      const subscribers = await this.getEventSubscribers(event);
      
      subscribers.forEach(connection => {
        connection.send(JSON.stringify({
          type: 'event',
          event: event
        }));
      });
    }
  }
}
```

### 4. サーバーレスWebSocket管理
```javascript
// AWS Lambda + API Gateway WebSocket
exports.handler = async (event, context) => {
  const { requestContext } = event;
  const { connectionId, routeKey } = requestContext;
  
  const apiGateway = new AWS.ApiGatewayManagementApi({
    endpoint: process.env.WEBSOCKET_ENDPOINT
  });
  
  try {
    switch (routeKey) {
      case '$connect':
        await handleConnect(connectionId, event);
        break;
        
      case '$disconnect':
        await handleDisconnect(connectionId);
        break;
        
      case 'message':
        await handleMessage(connectionId, JSON.parse(event.body));
        break;
        
      default:
        console.log('Unknown route:', routeKey);
    }
    
    return { statusCode: 200 };
    
  } catch (error) {
    console.error('Error:', error);
    return { statusCode: 500 };
  }
  
  async function handleConnect(connectionId, event) {
    // DynamoDBに接続情報保存
    const params = {
      TableName: 'WebSocketConnections',
      Item: {
        connectionId,
        userId: event.requestContext.authorizer?.userId,
        connectedAt: Date.now()
      }
    };
    
    await dynamodb.put(params).promise();
  }
  
  async function handleMessage(connectionId, message) {
    // ビジネスロジック処理
    const result = await processBusinessLogic(message);
    
    // 関連する接続に配信
    const connections = await getRelatedConnections(message.targetUsers);
    
    await Promise.all(connections.map(async (conn) => {
      try {
        await apiGateway.postToConnection({
          ConnectionId: conn.connectionId,
          Data: JSON.stringify(result)
        }).promise();
      } catch (error) {
        if (error.statusCode === 410) {
          // 無効な接続を削除
          await removeConnection(conn.connectionId);
        }
      }
    }));
  }
};
```

この包括的なバックエンド統合アーキテクチャにより、スケーラブルで保守性の高いWebSocketシステムを構築できます。

</div>
</div>